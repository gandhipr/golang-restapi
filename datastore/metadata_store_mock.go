// Code generated by MockGen. DO NOT EDIT.
// Source: metadata_store.go

// Package datastore is a generated GoMock package.
package datastore

import (
	utils "apiserver/utils"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockStoreIf is a mock of StoreIf interface.
type MockStoreIf struct {
	ctrl     *gomock.Controller
	recorder *MockStoreIfMockRecorder
}

// MockStoreIfMockRecorder is the mock recorder for MockStoreIf.
type MockStoreIfMockRecorder struct {
	mock *MockStoreIf
}

// NewMockStoreIf creates a new mock instance.
func NewMockStoreIf(ctrl *gomock.Controller) *MockStoreIf {
	mock := &MockStoreIf{ctrl: ctrl}
	mock.recorder = &MockStoreIfMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStoreIf) EXPECT() *MockStoreIfMockRecorder {
	return m.recorder
}

// AddApplication mocks base method.
func (m *MockStoreIf) AddApplication(arg0 utils.Metadata) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddApplication", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddApplication indicates an expected call of AddApplication.
func (mr *MockStoreIfMockRecorder) AddApplication(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddApplication", reflect.TypeOf((*MockStoreIf)(nil).AddApplication), arg0)
}

// DeleteApplication mocks base method.
func (m *MockStoreIf) DeleteApplication(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteApplication", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteApplication indicates an expected call of DeleteApplication.
func (mr *MockStoreIfMockRecorder) DeleteApplication(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteApplication", reflect.TypeOf((*MockStoreIf)(nil).DeleteApplication), arg0)
}

// DeleteApplicationWithVersion mocks base method.
func (m *MockStoreIf) DeleteApplicationWithVersion(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteApplicationWithVersion", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteApplicationWithVersion indicates an expected call of DeleteApplicationWithVersion.
func (mr *MockStoreIfMockRecorder) DeleteApplicationWithVersion(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteApplicationWithVersion", reflect.TypeOf((*MockStoreIf)(nil).DeleteApplicationWithVersion), arg0, arg1)
}

// GetAllMetadata mocks base method.
func (m *MockStoreIf) GetAllMetadata() ([]utils.Metadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAllMetadata")
	ret0, _ := ret[0].([]utils.Metadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAllMetadata indicates an expected call of GetAllMetadata.
func (mr *MockStoreIfMockRecorder) GetAllMetadata() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllMetadata", reflect.TypeOf((*MockStoreIf)(nil).GetAllMetadata))
}

// GetApplication mocks base method.
func (m *MockStoreIf) GetApplication(arg0 string) ([]utils.Metadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplication", arg0)
	ret0, _ := ret[0].([]utils.Metadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplication indicates an expected call of GetApplication.
func (mr *MockStoreIfMockRecorder) GetApplication(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplication", reflect.TypeOf((*MockStoreIf)(nil).GetApplication), arg0)
}

// GetApplicationWithVersion mocks base method.
func (m *MockStoreIf) GetApplicationWithVersion(arg0, arg1 string) (utils.Metadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationWithVersion", arg0, arg1)
	ret0, _ := ret[0].(utils.Metadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationWithVersion indicates an expected call of GetApplicationWithVersion.
func (mr *MockStoreIfMockRecorder) GetApplicationWithVersion(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationWithVersion", reflect.TypeOf((*MockStoreIf)(nil).GetApplicationWithVersion), arg0, arg1)
}

// UpdateApplicationForVersion mocks base method.
func (m *MockStoreIf) UpdateApplicationForVersion(arg0 utils.Metadata) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateApplicationForVersion", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateApplicationForVersion indicates an expected call of UpdateApplicationForVersion.
func (mr *MockStoreIfMockRecorder) UpdateApplicationForVersion(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateApplicationForVersion", reflect.TypeOf((*MockStoreIf)(nil).UpdateApplicationForVersion), arg0)
}

// isApplicationPresent mocks base method.
func (m *MockStoreIf) isApplicationPresent(arg0, arg1 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "isApplicationPresent", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// isApplicationPresent indicates an expected call of isApplicationPresent.
func (mr *MockStoreIfMockRecorder) isApplicationPresent(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "isApplicationPresent", reflect.TypeOf((*MockStoreIf)(nil).isApplicationPresent), arg0, arg1)
}

// isTitlePresent mocks base method.
func (m *MockStoreIf) isTitlePresent(arg0 string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "isTitlePresent", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// isTitlePresent indicates an expected call of isTitlePresent.
func (mr *MockStoreIfMockRecorder) isTitlePresent(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "isTitlePresent", reflect.TypeOf((*MockStoreIf)(nil).isTitlePresent), arg0)
}

// isVersionPresent mocks base method.
func (m *MockStoreIf) isVersionPresent(arg0, arg1 string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "isVersionPresent", arg0, arg1)
	ret0, _ := ret[0].(bool)
	return ret0
}

// isVersionPresent indicates an expected call of isVersionPresent.
func (mr *MockStoreIfMockRecorder) isVersionPresent(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "isVersionPresent", reflect.TypeOf((*MockStoreIf)(nil).isVersionPresent), arg0, arg1)
}
